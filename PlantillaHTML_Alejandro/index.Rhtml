<html>

<head>
    <meta charset="utf-8">

    <!-- Etiqueta imprescindible para que los dispositivos pongan el viewport
    del mismo tamaño que su ancho y no tengan zoom inicial -->
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Hoja de estilos para empezar con un estilo (casi) nulo (obtenida en http://cssreset.com) -->
    <link href="CSS/reset.css" rel="stylesheet" type="text/css" />

    <!-- Tipografías usadas -->
    <link href='https://fonts.googleapis.com/css?family=Merriweather' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Vollkorn:400,400italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Cousine' rel='stylesheet' type='text/css'>

    <!-- Hoja de estilos general -->
    <link href="CSS/estilo.css" rel="stylesheet" type="text/css" />

    <title>EC: Alejandro García Montoro</title>
</head>

<body>
    <!-- Div necesario para centrar todo el contenido y darle un ancho específico -->
    <div id="wrapper">

        <header>
            <div id="nombre">
                <h1>Estadística Computacional</h1>
            </div>
        </header>

        <div id="examen">
            Soluciones al examen final de la asignatura Estadística Computacional de la UGR
        </div>

        <div id="datos">
            <h2>Datos</h2>

            <div id="datos_contenido">
                <dl>
                    <dt>Nombre</dt>
                        <dd>Alejandro.</dd>
                    <dt>Apellidos</dt>
                        <dd>García Montoro.</dd>
                    <dt>DNI</dt>
                        <dd>76628233F</dd>
                    <dt>Grupo</dt>
                        <dd>Doble grado en ingeniería informática y matemáticas.</dd>
                </dl>
            </div>
        </div>

        <section id="soluciones">
            <h2>Soluciones al examen</h2>

            <div id="textoSol">
                <div class="ejercicio">
                    <div class="enunciado">
                        <p class="cabecera">Introducción:<p>
                        <p>
                          Considera en el plano un cuadrado centrado en el origen, de lado 200.
                        </p>
                        
                        <p>
                          Considera un punto que comienza en el origen y se desplaza del siguiente modo:
                          <ol>
                            <li>En cada paso se lanzan dos monedas.</li>
                            <li>Si la primera moneda es cara, el punto se mueve una unidad a la derecha, si es cruz lo hace a la izquierda.</li>
                            <li>Si la segunda moneda es cara, el punto se mueve una unidad hacia arriba, si es cruz lo hace hacia abajo.</li>
                            <li>El proceso finaliza si se llega a algún punto del perímetro del cuadrado.</li>
                          </ol>
                        </p>
                    </div>
                </div>
                
                <div class="ejercicio">
                    <div class="enunciado">
                        <p class="cabecera">Ejercicio 1:<p>
                        <p>
                            Función que simule el movimiento del punto y devuelva:
                            <ol>
                              <li> La progresión aleatoria definida.</li>
                              <li> Cuántos pasos han sido necesarios para llegar al límite.</li>
                              <li> La función debe tener un argumento que limite el número de movimientos y que si se alcanza devuelva una frase que diga "No he terminado de moverme" y, en caso contrario, que diga "He llegado al límite".</li>
                            </ol>
                        </p>
                    </div>
                    <div class="solucion">
                        <p>Definimos la función requerida, en la que el lanzamiento de la moneda lo simularemos con la función <code>sample</code>, tomando dos muestras con reemplazamiento del conjunto <code>{1,2}</code>, donde <code>1</code> representa la cara de la moneda y <code>2</code>, la cruz.</p>

<!--begin.rcode
movimiento <- function(maxIter = 10, mostrar = F){
  # Definimos la posición inicial
  pos <- c(0,0)
  
  # Inicializamos la matriz que contendrá, en la fila i-ésima, la posición
  # de la partícula en el instante i-ésimo
  camino <- matrix(pos, ncol=2, byrow=T)
  
  # Inicializamos el contador de iteraciones
  iteraciones <- 0
  
  while( !(100 %in% abs(pos)) && iteraciones < maxIter){
    # Simulamos las dos monedas: 1 es cara; 2 es cruz:
    monedas <- sample(1:2, 2, replace = T)
    
    # Determinamos el movimiento: si la primera moneda es cara (1), nos
    # movemos una unidad a la derecha; es decir, sumamos uno en el eje X;
    # si es cruz (2), a la izquierda: restamos uno en el eje X. Hacemos
    # lo mismo con la segunda moneda, que representa el eje Y.
    movimiento <- ifelse(monedas == 1, 1, -1)
    
    # Actualizamos la posición.
    pos <- pos + movimiento
    
    # Actualizamos la progresión
    camino <- rbind(camino, pos)
    
    # Actualizamos las iteraciones
    iteraciones <- iteraciones + 1
  }
  
  if(100 %in% abs(pos)){
    if(mostrar){
      cat("He llegado al límite.\n")
    }
    exito <- T
  }
  else{
    if(mostrar){
      cat("No he terminado de moverme.\n")
    }
    exito <- F
  }
  
  return(list(Progresion = camino, Pasos = iteraciones, Exito = exito))
}
end.rcode-->
                    </div>
                </div>

                <div class="ejercicio">
                    <div class="enunciado">
                        <p class="cabecera">Ejercicio 2:<p>
                        <p>
                            Una simulación del proceso y representación gráfica del movimiento.
                        </p>
                    </div>
                    <div class="solucion">
                        <p>Para simular el proceso simplemente tenemos que llamar a la función con el número máximo de iteraciones que se requieran. Podemos llamarlo con <code>10000</code> iteraciones:</p>
                        
                        
<!--begin.rcode
res <- movimiento(10000, mostrar = T)
end.rcode-->

<!--begin.rcode include=FALSE
mensaje <- ifelse(res$Exito, "sí", "no")
end.rcode-->


                        <p>Además de con el mensaje impreso, podemos comprobar si hemos llegado o no al borde con el resultado devuelto: como <code>res$Exito = </code><!-- rinline res$Exito-->, podemos confirmar que <!-- rinline I(mensaje)--> se ha llegado al borde del cuadrado.</p>
                        <p>Para hacer un gráfico del proceso, simplemente tenemos que recuperar el camino con el elemento <code>Progresion</code> de la lista devuelta por el método y dibujar los puntos de ese vector. Podemos añadir, para la mejor visualización del gráfico, unas líneas que representen el borde del recinto y un par de puntos que representen el punto inicial y el punto final.
                      

<!--begin.rcode
# Gráfico del progreso
plot(res$Progresion, type="l", col="steelblue", asp=1,
     xlim=c(-100,100), xlab="Eje X",
     ylim=c(-100,100), ylab="Eje Y",
     main="Progresión del punto")

# Añadimos los puntos iniciales y final
punto.inicial <- c(0,0)
punto.final <- t(res$Progresion[nrow(res$Progresion),])
points(rbind(punto.inicial, punto.final), pch=20, col="blue")

# Añadimos los bordes del recinto cuadrado
abline(h=c(-100,100), v=c(-100,100), col="coral")
end.rcode-->
                    </div>
                </div>

                <div class="ejercicio">
                    <div class="enunciado">
                        <p class="cabecera">Ejercicio 3:<p>
                        <p>
                            Una función con un argumento que permita repetir un número de veces, <code>n</code>, este proceso y devuelva un vector con el número de pasos necesarios para salir del recinto en cada repetición.
                        </p>
                    </div>
                    <div class="solucion">
                        <p>Definimos la función solicitada, en la que usamos <code>replicate</code>, una función de <code>R</code> que permite repetir un proceso tantas veces como se le indique. Como lo que queremos es el número de pasos, lo que haremos será repetir <code>n</code> veces la llamada a <code>movimiento</code>, tomando el resultado que nos interesa: el elemento <code>Pasos</code> de la lista devuelta:</p>

<!--begin.rcode
repeticion <- function(n = 1000, maxPasos = 10000){
  return(replicate(n, movimiento(maxPasos)$Pasos))
}
end.rcode-->
                    </div>
                </div>
                
                <div class="ejercicio ultimo">
                    <div class="enunciado">
                        <p class="cabecera">Ejercicio 4:<p>
                        <p>
                            Ejecuta la función repitiendo 100 veces el proceso inicial y calcula el tiempo medio de salida.
                        </p>
                    </div>
                    <div class="solucion">
                        <p>Para tomar la media de pasos necesarios para salir del recinto en 100 repeticiones del proceso del movimiento, basta llamar a la función anteriormente definida y ejecutar <code>mean</code> sobre el vector devuelto:</p>
<!--begin.rcode
pasos <- repeticion(100)
media <- mean(pasos)
end.rcode-->

                        <p>Tenemos así que, de media, se necesitan unos <!-- rinline I(media) --> pasos para salir del recinto.
                    </div>
                </div>
            </div>
        </section>
        
        <div class="clear"></div>
    </div>
    <footer>Granada, a 8 de junio de 2016</footer>
</body>

</html>
